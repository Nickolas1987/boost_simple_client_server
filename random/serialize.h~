#pragma once
#include <boost/fusion/algorithm/iteration/for_each.hpp>
#include <boost/fusion/include/for_each.hpp>
#include <boost/fusion/container/vector.hpp>
#include <boost/fusion/include/vector.hpp>
#include <boost/fusion/container/vector/vector_fwd.hpp>
#include <boost/fusion/include/vector_fwd.hpp>
#include <boost/fusion/container/generation/make_vector.hpp>
#include <boost/fusion/include/make_vector.hpp>
#include <boost/fusion/sequence/comparison/equal_to.hpp>
#include <boost/fusion/include/equal_to.hpp>

#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/serialization/serialization.hpp>
namespace test_np{
template<typename archive_type>
struct item_serializer {
   item_serializer(archive_type& ar):ar(ar) {}

   template<typename T>
   void operator()(const T& o) const {
      ar << o;
   }
   archive_type& ar;
};

template<typename archive_type, typename V>
archive_type& serialize_fusion_vector(archive_type& ar, const V& v) {
   boost::fusion::for_each(v, item_serializer<archive_type>(ar));
   return ar;
}

template<typename archive_type>
struct item_deserializer {
   item_deserializer(archive_type& ar):ar(ar) {}

   template<typename T>
   void operator()(T& o) const {
      ar >> o;
   }
   archive_type& ar;
};

template<typename archive_type, typename V>
archive_type& deserialize_fusion_vector(archive_type& ar, V& v) {
   boost::fusion::for_each(v, item_deserializer<archive_type>(ar));
   return ar;
}
}